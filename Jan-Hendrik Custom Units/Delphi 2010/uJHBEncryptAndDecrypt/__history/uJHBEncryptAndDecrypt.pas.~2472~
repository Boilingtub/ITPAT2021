unit uJHBEncryptAndDecrypt;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, ComCtrls , ExtCtrls, Buttons, Math, MAPI, ShellApi;

const
  MAX64BIT = 18446744073709551615;
  UTF8VALUE = $FFFF;
  ASCIIVALUE = 255;
  BITLENGTHVALUE_BITLENGTH = 64;
  MARKINGSTRING = '!@#$%^&*(ujhbEncryptAndDecrypt!!!!;{[//MARKING\\]})';
  FeistelRounds = 15;
  PublicKey = '';
  // cUnitNameSentinel = '$$$sentinel$$$';

 type
 TGeneric<T> = class
 Value : T;
 ArrValue : array of T;
 end;

 TArrayofString = array of string;
 TArrayofBytes = array of byte;
 TBinary = array of boolean;

var
  TGenericBool : TGeneric<boolean>;
  TGenericInt : TGeneric<integer>;
  TGenericStr : TGeneric<string>;

  sThisUnitDir: string;
  sSecurityString: string;
  ArrEncryptNumbers : Array[0 .. ASCIIVALUE] of integer;
  BitMap : TBitMap;
  iCurrentPosInBMP : integer;
  bDEBUGBOOL : boolean;
  sNewFilename : string;

procedure WriteToDebugtf(Sinput : string);


  // shell functions and procedures
function ExecuteExternalProgram(sExecuteFileDir, sParameters,sInitialDir: string): boolean;

function JHBEncrypt(SInput , SPassword : string): TBinary;
function JHBDecrypt(sBMPFilepath: string): string; overload;

function StrtoBin(sInput : String ) : TBinary;
function BintoStr(tbInput : TBinary ) : string;
function BinToInt(Binary: TBinary): uint64;
function InttoBin(INumber: integer): TBinary;
procedure BinArrDelete(var Arr : TBinary; const RemoveIndex : integer; RemoveAmount:integer);
Procedure JoinBinArr(var BinArr : TBinary ;const JoinArrBin : TBinary);
function LengthenBinary(tbInput : TBinary; bBitLength: byte; bool : Boolean): TBinary;
Function CopyBinArr(Arr: TBinary ; iStart , iEnd : integer) : TBinary;
function RandomBinary(length:integer) : Tbinary;
function BinXOR(Bin1 , Bin2 : Tbinary) : Tbinary;
function Feistel(SInput : string ; bForward : boolean ; Keys : Array of TBinary) : String;
function GenerateKeysAndFeistelEncrypt(SInput : string ; sRecipientKey : String) : String;
function RecoverKeysAndFeistelDecrypt(SInput : string; sRecipientKey : String) : string;
function BinaryMultiply(Bin1 , Bin2 : TBinary) : TBinary;
function BinaryAddition(Bin1 , Bin2 : TBinary) : TBinary;
function BoolToInt(B : Boolean) : shortint;
function IntToBool(si : ShortInt) : Boolean;
procedure EqualBinLengths(var Bin1 , Bin2 : TBinary);
function BinaryPower(Bin1 , Bin2 : TBinary) : TBinary;
function BinarySubtract(Bin1,Bin2 : TBinary) : TBinary;
Function BinaryModulo(Bin1 , Bin2 : TBinary) : TBinary;
function StrOrdtoBinArr(sInput : string; BitsPerChar , BinaryLength : integer) : TBinary;
function CheckifBinLarger(Bin1 , Bin2 : TBinary) : ShortInt;
Procedure TrimBin(var Bin1 : TBinary);

procedure CreateBitMap(Width, Height: integer; Color: TColor;const FileName: string);
procedure HideBinaryStringInBitMap(BintoHide: TBinary; const BMPFileName: string);
function JHBWIndowsOpenDialog(Title, Filter: string): string;
procedure CreateInputFormEncryption();
function RetriveBinFromBMP(BitMap: TBitmap; StartPoint, StringLength: integer): TBinary;
function ArrDecryptString(bBitlength : byte ; binInput : TBinary) : String;
function ArrEncryptString(sInput : String ; bBitlength : byte): TBinary;

Function JHBInputQuery(const sCaption , sHeading , sDiscription : string ; var sVar : string) : boolean; overload;

// Database functions and procedures;
function  CheckIfUserExistsInDataBase(UserName, UserPassword, UserEmailAdress: string; searchName, searchPassword, searchEmail: boolean): boolean;
procedure InsertRecordsIntoDB_usrtbl(UserName, UserPassword, UserEmailAdress, UserUsage: string);
procedure InsertNewDataIntoExistingRecordDB_usrtbl(UserName, UserPassword,UserEmailAdress: string; insertname, insertpassword,insertEmailAdress: boolean);
Function SelectRecipientsFromDB(var arrUsers : TArrayofString) : boolean;
Procedure LogMessagetoDB(Sender , Receiver , MsgName : string);

// Email Functions and procedures;
// function SendEmailMAPI( const arrTO ,arrCC , arrBCC , arrAttachments: array of string; const Body , Subject : string ) : integer;
procedure SendEmail(EmailType: byte; sRecipient: array of string; AttachmentDir: string;SenderName: string; sExtraText:string);
function GetSeperatedValues(sInput , sSeperator : string) :  TArrayofString;

implementation

uses

  uJHBEncryptInputForm , uJHB_DB;


procedure SendEmail(EmailType: byte; sRecipient: array of string; AttachmentDir: string; SenderName: string ; sExtraText:string);
var
  Parameters, __SecurityString: string;
  bcount , bcount2: byte;
begin
for bcount := 0 to length(sRecipient)-1 do
 begin
  if EmailType = 0 then
  begin
    for bcount2 := 1 to 6 do
    begin
      __SecurityString := __SecurityString + inttostr(Random(10));
      sSecurityString := __SecurityString;
    end;
    Parameters := '/C java -jar JHBjavaEmail-1.0.jar' + ' ' + inttostr(EmailType) + ' ' + sRecipient[bcount] + ' ' + '''' + AttachmentDir + '''' + ' ' +__SecurityString + ' ' + sExtraText;
  end;


  if EmailType = 1 then
  begin
    Parameters := '/C java -jar JHBjavaEmail-1.0.jar' + ' ' + inttostr(EmailType) + ' ' + sRecipient[bcount] + ' ' + ''''  + AttachmentDir + '''' + ' ' + SenderName + ' ' + sExtraText;
  end;

  ExecuteExternalProgram('powershell', PWideChar(Parameters), sThisUnitDir + '/../uJHBEncryptExternalCode/java/JHBjavaEmail/');

end;
end;

function ExecuteExternalProgram(sExecuteFileDir, sParameters , sInitialDir: string): boolean;
var
  StartupInfo: TStartupInfo;
  ProcessInfo: TProcessInformation;
  //ErrorCode: DWORD;
begin
  Result := true;
  StartupInfo := Default(TStartupInfo);
  StartupInfo.cb := sizeof(StartupInfo);
  StartupInfo.dwFlags := STARTF_USESHOWWINDOW;
  //How to ShellExecute Windows should show
  StartupInfo.wShowWindow := SW_Hide;
  CreateProcess(pChar(nil), PWideChar(WideString(sExecuteFileDir + ' ')+ PWideChar(WideString(sParameters))), nil, nil, false, 0, nil, pChar(WideString(sInitialDir)), StartupInfo, ProcessInfo);
end;

// C:\Users\jhbri\OneDrive\Documents\Embarcadero\Studio\Delphi 2010\Delphi 2010 Custom Units\uJHBEncryptAndDecrypt\uJHBEncryptExternalCode\java\JHBjavaEmail

function CheckIfUserExistsInDataBase(UserName, UserPassword, UserEmailAdress : string; searchName , searchPassword , searchEmail : boolean): boolean;
 var
 bfoundName , bfoundPassword , bfoundEmail : boolean;
begin

  with uJHB_DB.JHBdataModule do
  begin
   DB_usrtbl.First;

    while NOT(DB_usrtbl.Eof) do
     begin

     bfoundName := DB_usrtbl['UserName'] = UserName;
     bfoundPassword := DB_usrtbl['UserPassword'] = UserPassword;
     bfoundEmail := DB_usrtbl['UserEmail'] = UserEmailAdress;

     if ((bfoundName = searchName) AND (bfoundPassword = searchPassword) AND (bfoundEmail = searchEmail)) then
     begin
      Result := true;
      exit;
     end;

     DB_usrtbl.Next;

     end;
   end;
     Result := false;
end;

procedure InsertRecordsIntoDB_usrtbl(UserName, UserPassword, UserEmailAdress,UserUsage: string);
var
sUniqueCOde : string;
icount : integer;
bCodeInvalid : boolean;
begin

  with uJHB_DB.JHBdataModule do
  begin

     bCOdeInvalid := true;
    while bCodeINvalid = true do
    begin
    sUniqueCode := '';
    for icount := 0 to 254 do
     begin
      sUniqueCOde := sUniqueCode + chr(RandomRange(1,255));
     end;
     if NOT DB_usrtbl.Locate('UserUniqueCode' , sUniqueCode , []) then
     bCodeInvalid := false;
    end;

    DB_usrtbl.Insert;
    DB_usrtbl['UserName'] := UserName;
    DB_usrtbl['UserPassword'] := UserPassword;
    DB_usrtbl['UserEmail'] := UserEmailAdress;
    DB_usrtbl['UserUsage'] := UserUsage;
    DB_usrtbl['UserUniqueCode'] := sUniqueCode;
    DB_usrtbl.Post;

  end;

end;

//Insert NEw Date intop REcord
Procedure InsertNewDataIntoExistingRecordDB_usrtbl(UserName, UserPassword,UserEmailAdress : string; insertname, insertpassword,insertEmailAdress : boolean);
var
  bfound: boolean;
begin
  bfound := false;

  with uJHB_DB.JHBdataModule do
  begin
    if (((insertname = true) AND (insertpassword = false) AND(insertEmailAdress = false)) OR ((insertname = false) AND(insertpassword = true) AND (insertEmailAdress = false)) OR((insertname = false) AND (insertpassword = false) AND(insertEmailAdress = true))) then
    begin

        if insertname = true then
         if (DB_usrtbl.Locate('UserPassword' , UserPassword , []) = true) AND(DB_usrtbl.locate('UserEmail' ,UserEmailAdress , []) = true) then
          begin
            DB_usrtbl.Edit;
            DB_usrtbl['UserName'] := UserName;
            bfound := true;

          end;

        if insertpassword = true then
         if (DB_usrtbl.locate('UserName' , UserName , []) = true) AND (DB_usrtbl.Locate('UserEmail' , UserEmailAdress , []) = true) then
          begin
            DB_usrtbl.Edit;
            DB_usrtbl['UserPassword'] := UserPassword;
            bfound := true;
          end;

        if insertEmailAdress = true then
          if (DB_usrtbl.locate('UserName' , UserName , []) = true) AND (DB_usrtbl.Locate('UserPassword' , UserPassword , [])) then
          begin
            DB_usrtbl.Edit;
            DB_usrtbl['UserEmail'] := UserEmailAdress;
            bfound := true;
          end;

       if bfound = false then
         begin
          showmessage('could not find record to replace');
         end;

      DB_usrtbl.Post;

      end
      else
      showmessage('only 1 of the last 3 arguments can be true');
    end;
   end;




Procedure LogMessagetoDB(Sender , Receiver , MsgName : String);
begin
   with uJHB_DB.JHBdataModule do
  begin
     DB_MsgLogstbl.Insert;
     DB_MsgLogsTbl['Date'] := Date();
     DB_MsgLogsTbl['Time'] := Time();
     DB_MsgLogsTbl['Sender'] := Sender;
     DB_MsgLogsTbl['Receiver'] := Receiver;
     DB_MsgLogsTbl['SentMessageName'] := MsgName;
     DB_MsgLogstbl.Post;
  end;
end;


/// --------------------------------------------------------
function StrtoBin(sInput : String ) : TBinary;
begin
Setlength(REsult,0);
while sInput <> '' do
begin
 Setlength(Result,length(Result)+1) ;
 if SInput[1] = '1' then
 Result[length(Result)-1] := true
 else if SInput[1] = '0' then
 Result[length(Result)-1] := false;
 Delete(sInput,1,1);
end;
end;

//-------------------------------------------------------------------

function BintoStr(tbInput : TBinary ) : string;
var
icount : integer;
begin

 Result := '';
 for icount := 0 to length(tbInput)-1 do
 begin
 if tbInput[icount] = true then
 Result := Result + '1'
 else if tbInput[icount] = false then
 Result := Result + '0';
 end;

end;

//----------------- ----------------------------------------

function BinToInt(Binary: TBinary): Uint64;
var
  icount , iBinaryNumber, INumber: integer;
begin
INumber := 0;
iBinaryNumber := 0;
for icount := 0 to length(Binary)-1 do
  begin
    if Binary[icount] = true then
      iBinaryNumber := 1
    else if Binary[icount] = false then
      iBinaryNumber := 0;
    INumber := INumber + trunc(iBinaryNumber * Power(2, icount));
  end;
  Result := INumber;
end;

//---------------------------------------------------------

function InttoBin(INumber: integer): TBinary;
var
  BinVal: boolean;
  icount : integer;
begin
Setlength(Result,0);
icount := 0;
  while INumber > 0 do
  begin
    if odd(INumber) then
      BinVal := true // represents 1 in binary
    else
     BinVal := false; // represents 0 in binary
     Setlength(Result,icount+1);
     Result[icount] := BinVal;
     INumber := INumber DIV 2;
     INC(icount);
  end;

end;

//----------------------------------------------------------

procedure BinArrDelete(var Arr : TBinary; const RemoveIndex : integer; RemoveAmount:integer);
var
iArrLength : integer ;
iRemovecount , icount : integer;
begin
for iRemovecount := 0 to RemoveAmount-1 do
begin
iArrLength := Length(Arr);

if iArrLength <= 0 then
  showmessage('Array is empty');
if RemoveIndex > iArrLength then
  showmessage('Remove Index out of bounds');

for icount := RemoveIndex + 1 to iArrLength  do
  Arr[icount - 1] := Arr[icount];
  SetLength(Arr, iArrLength - 1);
end;
end;


//---------------------------------------------------

Procedure JoinBinArr(var BinArr : TBinary ;const JoinArrBin : TBinary);
var
BinArrLength , icount : integer;
begin
   BinArrLength := Length(BinArr);
  SetLength(BinArr, BinArrLength + Length(JoinArrBin));
  for icount := 0 to High(JoinArrBin) do
    BinArr[BinArrLength + icount] := JoinArrBin[icount];
end;

// --------------------------------------------------------

Function CopyBinArr(Arr: TBinary ; iStart , iEnd : integer) : TBinary;
var
  icount: Integer;
begin
   if length(Arr) < iStart + iEnd then
   showmessage('{CopyBinArr} -> Cannot Copy That Far');
   Setlength(Result,0);
   Setlength(Result,iEnd);
   for icount := iStart to iStart + iEnd do
   Result[icount-iStart] := Arr[icount];
end;

// ------------------------------------------------------

function LengthenBinary(tbInput : TBinary; bBitLength: byte; bool : Boolean): TBinary;
var
iLength : integer;
icount : integer;
begin
  iLength := length(tbInput);
  if (length(tbInput) > bBitLength) then
  begin
    showmessage('Bin ' + inttostr(length(tbInput)) + ' is Longer than The bBitLength ' + inttostr(bBitLength) + ' Truncating.....');
    exit;
  end;
  Setlength(tbInput,bBitlength);

  if bool = true then
  for icount := iLength-1 to length(tbInput)-1 do
  tbInput[icount] := true;


  Result := tbInput;
end;

///--------OBOSLETE-----------------------------------------------
// ----------------------------------------------------------------------------

function STRBinToInt(SBinaryNumString: string): integer;
var
  bcount: byte;
  iBinaryNumber, INumber: integer;
begin
  iBinaryNumber := 0;
  INumber := 0;
  for bcount := 1 to length(SBinaryNumString) do
  begin
    if SBinaryNumString[bcount] = ('1') then
      iBinaryNumber := 1
    else if SBinaryNumString[bcount] = ('0') then
      iBinaryNumber := 0;
    INumber := INumber + trunc(iBinaryNumber * Power(2, bcount - 1));
  end;
  Result := INumber;
end;

// -----------------------------------------------

function STRInttoBin(INumber: integer): string;
var
  cBinCharvalue: Char;
  sOutput: string;
begin
  while INumber > 0 do
  begin
    if odd(INumber) then
      cBinCharvalue := '1' // represents 1 in binary
    else
      cBinCharvalue := '0'; // represents 0 in binary
    Insert(cBinCharvalue, sOutput, length(sOutput) + 1);
    INumber := INumber DIV 2;
  end;
  Result := sOutput;
end;
// ------------------------------------------------------------------

function LengthenBinaryString(SInput: string; bBitLength: byte): string;
begin
  if (length(SInput) > bBitLength) then
  begin
    showmessage('String ' + inttostr(length(SInput)) + ' is Longer than The bBitLength ' + inttostr(bBitLength) + ' Truncating.....');
    exit;
  end;

  while length(SInput) < bBitLength do
  begin
    SInput := SInput + '0';
  end;

  Result := SInput;
end;
// ---------------------------------------------------------------
function BinXOR(Bin1 , Bin2 : Tbinary) : Tbinary;
var
icount : integer;
begin
Setlength(Result,0);
EqualBinlengths(Bin1,Bin2);
Setlength(Result,length(bin1));
//showmessage('Bin1 : ' + bintostr(Bin1) + ' , ' + 'Bin2 : ' + bintostr(Bin2))  ;
for icount := 0 to length(Result)-1 do
  begin
    if Bin1[icount] = Bin2[icount] then
    Result[icount] := false
    else
    if  ( Bin1[icount] <> Bin2[icount] ) then
    Result[icount] := true;
  end;


end;
//-----------------------------------------------------------------
function IntToBool(si : ShortInt) : Boolean;
begin
if si > 0 then
Result := True
else
Result := false;
end;
//------------------------------------------------------------------
function BoolToInt(B : Boolean) : shortint;
begin
 if B = true then
 Result := 1
 else
 Result := 0;
end;
//-----------------------------------------------------------------------
function RandomBinary(length:integer) : Tbinary;
var
icount : integer;
begin
Setlength(Result,0);
Randomize;
for icount := 0 to length-1 do
JoinBinArr(Result,Strtobin(inttostr(RandomRange(0,2))));
end;
//-------------------------------------------------------------------------
procedure EqualBinLengths(var Bin1 , Bin2 : TBinary);
begin
if length(Bin1) > length(Bin2) then
begin
 Bin2 := LengthenBinary(Bin2,length(Bin1),false)
end
else if length(Bin1) < length(Bin2) then
begin
 Bin1 := LengthenBinary(Bin1,length(Bin2),false)
end;
end;
//----------------------------------------------------------------------------
function BinaryAddition(Bin1 , Bin2 : TBinary) : TBinary;
var
icount : integer;
Sival : ShortInt;
Bin3 : TBinary ;
begin
Setlength(Result,0);

EqualBinLengths(Bin1,Bin2);
 //showmessage(bintostr(bin1) + chr(10) + bintostr(bin2));
Setlength(Bin3,length(Bin1)+1);
for icount := 0 to length(Bin1)-1 do
begin
siVal := BooltoInt(Bin1[icount]) + BooltoInt(Bin2[icount]) +  BooltoInt(Bin3[icount]);
case SiVal of
3 : begin
    Bin3[icount+1] := true;
    Bin3[icount] := true;
    end;
2 : begin
    Bin3[icount+1]  := true;
    Bin3[icount] := false;
    end;
1 : Bin3[icount] := true;
end;

end;
 TrimBin(Bin3);
 Result := Bin3 ;
end;
//------------------------------------------------------------------------------
function BinarySubtract(Bin1,Bin2 : TBinary) : TBinary;
var
Bin3 : TBinary;
icount , ioffset : Integer;
siVal : ShortInt;
begin

Setlength(Result,0);
EqualBinLengths(Bin1,Bin2);
Setlength(Bin3,length(Bin1));
for icount := 0 to length(Bin1)-1 do
begin
 ioffset  := 0;
 siVal := BooltoInt(Bin1[icount]) - BooltoInt(Bin2[icount]);

 while siVal < 0 do
  begin
   Inc(iOffset);

   if (icount + ioffset) >= length(Bin1) then
   begin
     showmessage('Awnser is negative');
     exit;
   end;

   if Bin1[icount + ioffset] = true then
   begin
    Bin1[icount + ioffset] := false;
    siVal := 1;
   end
   else
   Bin1[icount + ioffset] := true;

  end;

Bin3[icount] := inttoBool(SiVal);
 //Showmessage(bintostr(Bin1) + chr(10) + Bintostr(Bin2) + chr(10) + Bintostr(Bin3))
end;
TrimBin(Bin3);
Result := Bin3 ;

end;
//--------------------------------------------------------------------------------
Procedure TrimBin(var Bin1 : TBinary);
var
icount : integer;
begin
 for icount := 0 to High(Bin1) do
 if Bin1[High(bin1)-icount] = true then
 begin
 setlength(Bin1,(High(bin1)-icount+1));
 break;
 end;
end;
//--------------------------------------------------------------------------------
function CheckifBinLarger(Bin1 , Bin2 : TBinary) : shortint;
var
icount : integer;
begin
TrimBin(Bin1);
TrimBin(Bin2);
Result := 0;
 if Length(Bin1) < length(Bin2) then
 Result := -1
 else if Length(Bin1) > length(Bin2) then
 Result := 1
 else if Length(Bin1) = length(Bin2) then
 begin
 for icount := 0 to High(Bin1) do
 begin
 if (Bin1[High(Bin1)-icount] = false) AND (Bin2[High(Bin2)-icount] = true) then
 begin
 Result:= -1;
 exit;
 end
 else  if (Bin1[High(Bin1)-icount] = true) AND (Bin2[High(Bin2)-icount] = false) then
 begin
 Result:= 1;
 exit;
 end;
 end;
 Result := 0;
 end;
end;

//-----------------------------------------------------------------------------
Function BinaryModulo(Bin1 , Bin2 : TBinary) : TBinary;
var
Bin3 : TBinary;
begin
TrimBin(bin1);
TrimBin(bin2);
Bin3 := Bin2;

while length(bin1) > length(bin2) do
Bin2 := BinaryAddition(Bin2 , Bin3);

Bin1 := BinarySubtract(Bin1,Bin2) ;


Result := Bin1;
end;
//---------------------------------------------------------------------------------
function BinaryMultiply(Bin1 , Bin2 : TBinary) : TBinary;
var
Bin3 : TBinary;
icount : integer;
ArrAdders : Array of TBinary;
begin
Setlength(Result,0);
for icount := 0 to length(bin2) do
begin
  Setlength(Bin3,0);
  Setlength(Bin3,icount);
  if Bin2[icount] = true then
  begin
  Setlength(ArrAdders,length(ArrAdders)+1);
  JoinBinArr(Bin3,Bin1);
  ArrAdders[High(ArrAdders)] := Bin3;
  end;
end;
for icount := 1 to High(ArrAdders) do
  begin
  ArrAdders[icount] := BinaryAddition( ArrAdders[icount-1]  , ArrAdders[icount]);
  end;
 Result :=   ArrAdders[High(ArrAdders)-1];

end;
//----------------------------------------------------------------------------

function BinaryPower(Bin1 , Bin2 : TBinary) : TBinary;
var
Bin3 : TBinary;
begin
Bin3 := Bin1;
while CheckifBinLarger(Bin2 , strtobin('1')) = 1 do
begin
 Bin3 := BinaryMultiply(Bin3,Bin1);
 Bin2 := BinarySubtract(Bin2 , strtoBin('1'));
end;
Result := Bin3;
end;
//-------------------------------------------------------------------------
function StrOrdtoBinArr(sInput : string; BitsPerChar , BinaryLength : integer) : TBinary;
var
icount : integer;
begin
Setlength(Result,0);
 icount := 0;
while (length(Result) < BinaryLength) AND (icount < length(sInput)) do
   begin
   JoinBinArr(Result , LengthenBinary(inttobin(ord(sInput[icount])),BitsPerChar,false));
   Inc(icount);
   end;

   while length(Result) < BinaryLength do
   JoinBinArr(Result , Result);

   Result := CopyBinArr(Result,0,BinaryLength) ;

end;
//---------------------------------------------------------------

function RecoverKeysAndFeistelDecrypt(SInput : string; sRecipientKey : String) : string;
var
ArrDividedStr : Array of String;
FeistelKeys : Array[0..FeistelRounds] of TBinary;
RecipientKey : TBinary;
icount , icount2 : integer;
sKeyStr : string;
TempBin : TBinary;
begin

 {for icount := 1 to length(SInput) do
  begin
   SInput[icount] := chr(ord(SInput[icount])-3) ;
  end;    }

 for icount := 1 to length(sInput) do
   if ord(SINput[icount]) > 255 then
   showmessage('icount : ' + inttostr(icount) + ' ord : ' + inttostr(ord(SInput[icount])));

RecipientKey := StrOrdtoBinArr(SRecipientKey,8,64);

 for icount := 0 to high(FeistelKeys) do
  begin
  sKeyStr := Copy(sInput,1,8);
  Delete(sInput,1,8);
  for icount2 := 1 to length(sKeyStr) do
   begin
   TempBin := LengthenBinary(inttoBin(ord(sKeySTr[icount2])),8,false);
   JoinBinArr(FeistelKeys[icount] , TempBin);
   end;

  FeistelKeys[icount] := BinXOR(FeistelKeys[icount] ,RecipientKey) ;
  end;

while sInput <> '' do
  begin
  Setlength(arrDividedStr,length(arrDividedstr)+1);
  ArrDividedStr[High(ArrDividedStr)] := Copy(sInput,1,16);
  Delete(sInput,1,16);
  end;

    for icount := 0 to high(arrDividedStr)-1 do
  begin
   arrDividedStr[icount] := Feistel(arrDividedStr[icount],false,FeistelKeys);
  end;

  if length(arrDividedStr[High(arrDividedStr)]) < 16 then
   for icount2 := 0 to High(FeistelKeys) do
   begin
     if length(FeistelKeys[icount2]) > length(arrDividedStr[high(arrDividedStr)])*4 then
      Setlength(FeistelKeys[icount2],length(arrDividedStr[high(arrDividedStr)])*4);
   end;

  arrDividedStr[High(arrDividedStr)] := Feistel(arrDividedStr[High(arrDividedStr)],false,FeistelKeys);

  sInput := '';
  for icount := 0 to High(arrDividedStr) do
  SInput := sInput + arrDividedStr[icount];


  Result := sInput;

end;
//----------------------------------------------------------------

function GenerateKeysAndFeistelEncrypt(SInput : string ; sRecipientKey : String) : String;
var
icount , icount2 : integer;
FeistelKeys : Array[0..FeistelRounds] of TBinary;
ArrDividedStr : Array of String;
RecipientKey , binRand : TBinary;
sKeyStr : String;
begin
  if Odd(length(sInput)) then
  sInput := sInput + ' ';

  RecipientKey := StrOrdtoBinArr(SRecipientKey,8,64);

  while sInput <> '' do
  begin
  Setlength(arrDividedStr,length(arrDividedstr)+1);
  ArrDividedStr[High(ArrDividedStr)] := Copy(sInput,1,16);
  Delete(sInput,1,16);
  end;


 for icount := 0 to high(FeistelKeys) do
  begin
  FeistelKeys[icount] := RandomBinary(64);
  for icount2 := 0 to 7 do
  begin
  skeyStr := sKeyStr + chr(Bintoint(CopyBinArr(FeistelKeys[icount],icount2*8,8)));
  end;

  FeistelKeys[icount] := BinXOR(FeistelKeys[icount] ,RecipientKey) ;

  end;

  for icount := 0 to high(arrDividedStr)-1 do
  begin
   arrDividedStr[icount] := Feistel(arrDividedStr[icount],true,FeistelKeys);
  end;

  if length(arrDividedStr[High(arrDividedStr)]) < 16 then
   for icount2 := 0 to High(FeistelKeys) do
   begin
     if length(FeistelKeys[icount2]) > length(arrDividedStr[high(arrDividedStr)])*4 then
      Setlength(FeistelKeys[icount2],length(arrDividedStr[high(arrDividedStr)])*4) ;
   end;

  arrDividedStr[High(arrDividedStr)] := Feistel(arrDividedStr[High(arrDividedStr)],true,FeistelKeys);

  sInput := '';
  for icount := 0 to High(arrDividedStr) do
  SInput := sInput + arrDividedStr[icount];

  Result := skeyStr + sInput;

   { for icount := 1 to length(Result) do
  begin
    Result[icount] := chr(Ord(Result[icount]) + 3);
    if Ord(Result[icount]) < 3 then
    showmessage(inttostr(Ord(Result[icount]))) ;
  end;  }

  end;




//----------------------------------------------------------------
function Feistel(SInput : string ; bForward : boolean ; Keys : Array of TBinary) : String;
const
ByteLength = 8;
var
Func : Array of TBinary;
Right : Array of TBinary;
Left : Array of TBinary;
TempBin : TBinary;
icount : Integer;
begin
Result := '';
if (odd(length(SInput))) AND bForward = true  then
showmessage('{Feistel} -> Sinput is Odd');

Setlength(Func,length(Keys));
Setlength(Left,length(Keys)+1);
Setlength(Right,length(Keys)+1);

for icount := 1 to length(SInput) DIV 2  do
begin
JoinBinArr(Left[0] , LengthenBinary(inttobin(ord(SInput[icount])),ByteLength,false));
JoinBinArr(Right[0] , LengthenBinary(inttobin(ord(SInput[icount + (length(SInput) DIV 2)])),ByteLength,false));
end;

if bForward = true then
begin

for icount := 0 to length(Keys)-1 do
  begin

    Func[icount] := BinXOR(Right[icount],Keys[icount]);
    Right[icount+1] := BinXOR(Func[icount] , Left[icount]);
    Left[icount+1] := Right[icount];

  end;

end
else
if bForward = false then
begin
   TempBin := Right[0];
   Right[0] := Left[0];
   Left[0] := TempBin;

for icount := 0 to length(Keys)-1 do
  begin

    Func[icount] := BinXOR(Right[icount],Keys[High(Keys)-icount]);
    Right[icount+1] := BinXOR(Func[icount] , Left[icount]);
    Left[icount+1] := Right[icount];

  end;

   TempBin := Right[High(Right)];
   Right[High(Right)] := Left[High(Left)];
   Left[High(Left)] := TempBin;

end;

JoinBinArr(Left[High(Left)] , Right[High(Right)]);
//Showmessage('Length: ' + inttostr(length(Left[High(Left)]))) ;
while length(Left[High(Left)]) > 0 do
  begin
    Result := Result + chr(BintoInt(CopyBinArr(Left[High(left)],0,ByteLength)));
    BinArrDelete(Left[High(Left)],0,ByteLength);
  end;

end;

// ---------------------------------------------------------------

function JHBEncrypt(SInput , SPassword string): TBinary;
var
  ArrTEMP: Array [0 .. ASCIIVALUE] of integer;
  iPasswordOrdValue : integer;
  icount, icount2: integer;
  bRandom, bBitLength : byte;
  binOutput , BinEnd: TBinary;
begin

  iPasswordOrdValue := 0;
   // ascii values of Password characters added together
  for icount := 1 to length(SPassword) do
   iPasswordOrdValue := iPasswordOrdValue + ORD(SPassword[icount]);

  // populate Arrays
  for icount := 0 to length(ArrEncryptNumbers) do
  begin
    ArrEncryptNumbers[icount] := icount;
    ArrTEMP[icount] := icount;
  end;

  // Calculate minimum bit length needed to encrypt the text;
  bBitLength := (length(InttoBin(iPasswordOrdValue + ASCIIVALUE)));
  if (bBitLength < length(InttoBin(length(SInput) + 128 + ASCIIVALUE))) then
    bBitLength := length(InttoBin(length(SInput) + 128 + ASCIIVALUE));
    //showmessage('bBitLength : ' + inttostr(bBitlength));
  // Insert SBitllength into thew begining of soutput to be saved;
  JoinBinArr(binOutput , LengthenBinary(InttoBin(bBitLength), BITLENGTHVALUE_BITLENGTH,false));

  for icount := 1 to length(sInput) do
    if Ord(sInput[icount]) > 255 then
    begin
      //showmessage('message contains unsupported Charcters which will have to be removed : ' + sInput[icount]);
      sInput[icount] := chr(3);
    end;

  // Generate FeistelKeys   // Feistel Encypt SInput;
  sInput := GenerateKeysAndFeistelEncrypt(SInput,SPassword);
 // showmessage(inttostr(length(sInput)));
  //showmessage('Encrypt : ' + sInput[1] + ' : ' + inttostr(ord(sInput[1])) + ' "" ' + sInput[length(sInput)] + ' : ' + inttostr(ord(sInput[length(sInput)]))+ ' [' + inttostr(length(sinput)) + '] ');
  { for icount := 1 to length(sInput) do
     if ORd(sInput[icount]) < 3 then
      showmessage('{E icount: ' + inttostr(icount) + ' ord : ' + inttostr(ORd(sInput[icount]))) ;   }

  { for icount := 1 to length(sInput) do
    begin
      if ord(sInput[icount]) < 2 then
       showmessage('icount : ' + inttostr(icount) + ' char : ' + inttostr(ord(sInput[icount])));
    end;   }

        SHowmessage('TEST');
  // Insert Final String end Character into Input string
  SInput := SInput + chr(0);
   // Insert Final String end Character into Password string
  sPassword := sPassword + chr(0);

  // Generate Key
  for icount := ASCIIVALUE downto 1 do
  begin
    Randomize();
    bRandom := RandomRange(icount,1);
    ArrEncryptNumbers[icount] := ArrTEMP[bRandom];
    ArrTEMP[bRandom] := ArrTEMP[icount];

    if (length(InttoBin(ArrEncryptNumbers[icount] + iPasswordOrdValue)) > bBitLength) then
    showmessage(inttostr(ArrEncryptNumbers[icount] + iPasswordOrdValue));
    JoinBinArr(BinOutput , LengthenBinary(InttoBin(ArrEncryptNumbers[icount]+ iPasswordOrdValue), bBitLength,false));
  end;

  //showmessage(bintostr(BinEnd));
  //Encrypt sPassword en SInput met eie array method
  JoinBinArr(binOutput , ArrEncryptString(sPassword,bBitlength));

  JoinBinArr(binOutput , ArrEncryptString(sInput,bBitlength));


  Setlength(BinEnd,1);
  Binend[0] := true;
  BinEnd := LengthenBinary(BinEnd,bBitlength,true);
  //showmessage(bintostr(BinEnd));
  JoinBinArr(binOutput , BinEnd);

  //showmessage(inttostr(bintoint(LengthenBinaryString(InttoBin(ArrEncryptNumbers[3]), bBitLength))));

  Result := binOutput;

end;

// --------------------------------------------------------------

function JHBDecrypt(sBMPFilepath: string): string;
var
  icount, icount2 , iPasswordOrdValue: integer;
  sOutput , sPassword : string;
  bBitLength: byte;
  binByte , BinInput , binKey , BinEnd : TBinary;
  bSearching : boolean;

begin



  if uJHB_DB.JHBdataModule.DB_usrtbl.Locate('UserName' , sUserName , []) then
  sPassword := uJHB_DB.JHBdataModule.DB_usrtbl['UserUniqueCode'];

  iCurrentPosInBMP := 0;
  iPasswordOrdValue := 0;
   // ascii values of Password characters added together
  for icount := 1 to length(SPassword) do
    iPasswordOrdValue := iPasswordOrdValue + ORD(SPassword[icount]);
  // cut out comment
  { icommentendpos := pos('0' , sencryptedtext);
    Delete(sEncryptedtext , 1 , iCommentENdPos); }

    try
    BitMap := TBitmap.create;

    if (sBMPFilepath = '') then
    begin
      Result := 'no file was chosen';
      exit;
    end;
    BitMap.LoadFromFile(sBMPFilepath);
    bBitLength := BinToInt(RetriveBinFromBMP(BitMap, 0,BITLENGTHVALUE_BITLENGTH));
    iCurrentPosInBMP := BITLENGTHVALUE_BITLENGTH;

    Setlength(BinEnd,1);
    Binend[0] := true;
    BinEnd := LengthenBinary(BinEnd,bBitlength,true);


   // showmessage(inttostr(bintoint(sBMPFinalChar)));
    //Extract String form BitMap !!!
    bSearching := true;
    while bSearching = true do
    begin

       binByte := RetriveBinFromBMP(BitMap, iCurrentPosInBMP, bBitLength);
       iCurrentPosInBMP := iCurrentPosInBMP + bBitLength;

       if bintoint(BinByte) = bintoint(BinEnd) then
        begin
            bSearching := false;
          end
        else
        JoinBinArr(BinInput , BinByte);

    end;
    finally
      FreeAndNil(Bitmap);
    end;

   // Get key from text and remove unneccesary bits
   binKey := CopyBinArr(BinInput, 0, (ASCIIVALUE) * bBitLength);
   BinArrDelete(BinInput , 0, (ASCIIVALUE) * bBitLength);

  // assign ArrEncryptNumbers[icount] to the key values   USING sKEY
   try
  for icount := ASCIIVALUE downto 1 do
  begin

    ArrEncryptNumbers[icount] := BinToInt(CopyBinArr(binKey, 0, bBitLength)) - iPasswordOrdValue;
    //Showmessage(inttostr(icount) + ' ' +  Bintostr(ArrEncryptNumbers[icount]));
    if (ArrEncryptNumbers[icount] < 0) OR (ArrEncryptNumbers[icount] > ASCIIVALUE) then
    begin
      Result := MARKINGSTRING + 'You are not the intended recipient of this message';
      exit;
    end;
    // showmessage(inttostr(BinToInt(COpy(skey,1,bBITLENGTH)) - ipasswordORDvalue));
    BinArrDelete(BinKey, 0, bBitLength);
  end;
  except
  Result := (MARKINGSTRING + 'Something went wrong ! , Image Data may be corrupted Or there is no Data in the image');
  exit;
  end;
       //showmessage(inttostr(length(BinInput) DIV bBitlength))  ;
  //showmessage('Sinput length : ' + inttostr(length(sInput)) + ' / ' + inttostr(bBitlength) + ' = ' + inttostr(length(sInput) DIV bBitlength));
  sOUtput := ArrDecryptString(bBitlength , BinInput);
    // showmessage(inttostr(length(sOutput)))  ;

  // Check if entered password matches encrypted password
  if (copy(sOutput,1,Pos(chr(0),sOutput)-1) <> SPassword) then
  begin
    Result := MARKINGSTRING + 'You are not the intended recipient of this message';
    exit;
  end;
  Delete(sOutput,1,Pos(chr(0),sOutput));
  Delete(sOutput,length(sOutput),1);
 { for icount := 1 to length(sOutput) do
  if ord(sOutput[icount]) < 2 then
  showmessage(inttostr(ord(sOutput[icount]))) ;   }
   //showmessage(inttostr(length(sOutput)));

   {   for icount := 1 to length(sOutput) do
     if ORd(sOutput[icount]) < 3 then
      showmessage('{D icount: ' + inttostr(icount) + ' ord : ' + inttostr(ORd(sOutput[icount]))) ; }
  //showmessage('DeCrypt : ' + sOutput[1] + ' : ' + inttostr(ord(sOutput[1])) + ' "" ' + sOutput[length(sOutput)] + ' : ' + inttostr(ord(sOutput[length(sOutput)])) + ' [' + inttostr(length(sOutput)) + '] ');
  sOutput := RecoverKeysAndFeistelDecrypt(sOutput,sPassword);


  Result := sOutput;


end;





function ArrEncryptString(sInput : String ; bBitlength : byte): TBinary;
var
icount , icount2 : integer;
begin

   for icount := 1 to length(SInput) do
  begin

    for icount2 := 0 to ASCIIVALUE do
    begin
      if chr(icount2) = (Copy(SInput, 1, 1)) then
      begin
        JoinBinARR(Result , LengthenBinary(InttoBin(ArrEncryptNumbers[icount2] + length(sInput)),bBitlength,false));//Insert(LengthenBinaryString(STRInttoBin(ArrEncryptNumbers[icount2] + length(SInput)), bBitLength), Result, length(Result) + 1); // Inserting Numbers and Converting them to CharBin in to sEncryptedText
      end;
    end;
    Delete(SInput, 1, 1);
  end;
end;




function ArrDecryptString(bBitlength : byte ; binInput : TBinary) : String;
var
bSearching : boolean;
icount2  : integer;
binSnippet : TBinary;
TF : TextFile;
begin

Result := '';

while length(BinInput) > 0 do
begin
 bSearching := true;

  while bSearching = true do
   begin
     if (ArrEncryptNumbers[0] = BinToInt(CopyBinArr(BinInput,0,bBitlength)) -1 ) then
     begin
       bSearching := false;
     end;
     JoinBinArr(BinSnippet , CopyBinArr(BinInput,0,bBitlength));
     BinArrDelete(BinInput, 0, bBitLength);
   end;

    while length(binSnippet) > 0 do
    begin
      for icount2 := 0 to ASCIIVALUE do
       begin

        if ArrEncryptNumbers[icount2] = BinToInt(CopyBinArr(BinSnippet, 0, bBitLength)) - (length(BinSnippet) DIV bBitLength) then
         begin
          Result := Result + chr(icount2);
          break;
         end;
       end;

       BinArrDelete(BinSnippet, 0, bBitLength);
    end;
end;
end;









function GetSeperatedValues(sInput , sSeperator : string) :  TArrayofString;
begin
sInput := SInput + sSeperator;
while sInput <> '' do
begin
 if Trim(Copy(sInput,1,Pos(sSeperator,sInput)-1)) <> '' then
  begin
   Setlength(Result , length(Result)+1);
   Result[length(Result)-1] := Trim(Copy(sInput,1,Pos(sSeperator,SInput)-1));
   end;
  Delete(sInput,1,Pos(sSeperator,sInput)) ;
end;
end;









function RetriveBinFromBMP(BitMap: TBitmap; StartPoint, StringLength: integer): TBinary;
var
  icount, x, y: integer;
begin
  Setlength(Result,0);
  x := trunc(StartPoint / BitMap.Height);
  y := round(frac(StartPoint / BitMap.Height) * BitMap.Height) - 1;
  // showmessage(' x : ' + inttostr(x) + ' y : ' + inttostr(y));

  for icount := 1 to StringLength do
  begin

    inc(y);
    if (y >= BitMap.Height) then
    begin
      y := 0;
      inc(x);
    end;

    if ODD(BitMap.Canvas.Pixels[x, y]) then
    JoinBinArr(Result , strtobin('1'))
    else
    JoinBinArr(Result , strtobin('0'));

  end;

end;

procedure HideBinaryStringInBitMap(BintoHide: TBinary; const BMPFileName: string);
var
  BitMap: TBitmap;
  x, y, iStr: integer;
  PixColorBin : TBinary;
begin
  BitMap := TBitmap.create;
  try

    if (BMPFileName = '') then
    begin
      showmessage('there is no file selected');
      exit;
    end;

    BitMap.LoadFromFile(BMPFileName);

    x := 0;
    y := -1;

    if ((BitMap.Height) * (BitMap.Width) < length(BinToHide)+1) then
    begin
      showmessage('This Image is to small to hold all the Data. Please choose a larger image');
      exit;
    end;

    for iStr := 0 to length(BinToHide)-1 do
    begin

      {if NOT(CharinSet(BinToHide[iStr], ['1', '0'])) then
      begin
        showmessage(
          'the String you are Trying to hide is not binary. Please Encrypt again and retry');
        exit;
      end;  }

      inc(y);
      if y >= BitMap.Height then
      begin
        y := 0;
        inc(x);
      end;

      case BitMap.PixelFormat of
        pf1bit : begin
                 if BinToHide[iStr] = false then
                 BitMap.Canvas.Pixels[x, y] := 0
                 else
                 if BinToHide[iStr] = true then
                 BitMap.Canvas.Pixels[x, y] := 16777215;
                 end;

        pf4bit : begin
                 BitMap.PixelFormat := pf24bit ;
                 HideBinaryStringInBitMap(BintoHide,BMPFileName) ;
                 end;

        pf8bit : begin
                 BitMap.PixelFormat := pf24bit ;
                 HideBinaryStringInBitMap(BintoHide,BMPFileName);
                 end;

        pf15bit : begin
                  BitMap.PixelFormat := pf24bit ;
                  HideBinaryStringInBitMap(BintoHide,BMPFileName);
                  end;

        pf16bit : begin
                  BitMap.PixelFormat := pf24bit ;
                  HideBinaryStringInBitMap(BintoHide,BMPFileName);
                  end;

        pf24bit , pf32bit : begin
                            PixColorBin := InttoBin(BitMap.Canvas.Pixels[x, y]);
                            PixColorBin := StrtoBin(inttostr(ABS(strtoint(Booltostr(BinToHide[istr])))) + Copy(BintoStr(Pixcolorbin),2,length(PixcolorBin)+1));
                            BitMap.Canvas.Pixels[x, y] := BinToInt(PixColorBin);
                            end ;
      end;
    end;

    sNewFilename := BMPFileName;
    while Pos('\',sNewFilename) > 0 do
    Delete(sNewFileName,1,Pos('\',sNewFileName));

    sNewFileName := 'C:\uJHBENcryptAndDecryptEncryptedImage\' + sNEwFileName;
    ForceDirectories('C:\uJHBENcryptAndDecryptEncryptedImage\');
    BitMap.SaveTofile(sNewFilename);

  finally
    BitMap.Free;
  end;
end;

function JHBWIndowsOpenDialog(Title, Filter: string): string;
var
  opendialog: topendialog;
begin
  opendialog := topendialog.create(nil);
  opendialog.Title := Title;
  opendialog.Filter := Filter;
  opendialog.InitialDir := GetCurrentDir;
  opendialog.Options := [ofFileMustExist];
  if opendialog.Execute then
    Result := opendialog.FileName;
  opendialog.Free;

end;

procedure CreateBitMap(Width, Height: integer; Color: TColor; const FileName: string);
var
  BitMap: TBitmap;
begin
  BitMap := TBitmap.create;
  try

    BitMap.PixelFormat := pf32bit;
    BitMap.Width := Width;
    BitMap.Height := Height;
    BitMap.Canvas.Brush.Color := Color;
    BitMap.Canvas.FillRect(Rect(0, 0, Width, Height));
    BitMap.SaveTofile(FileName);

  finally
    BitMap.Free;
  end;
end;

procedure CreateInputFormEncryption();
var
  FormEI: Tform;
begin
  FormEI := frmEncryptInput.create(nil);
  FormEI.Showmodal;
end;






Function SelectRecipientsFromDB(var arrUsers : TArrayofString) : boolean;
const
mrUpdate = 30;
var
Form : TForm;
cb : Array of TCheckBox;
btn : Array[0..2] of TButton;
rgb : TRadioGroup;
lblHeading : Tlabel;
ScrollBox : TScrollBox;
iFormModal , icount : integer;
bFormOpen : boolean;
sField : string;
begin
Result := false;
 try

 Form := TForm.Create(application);
 with Form do
  begin
    Canvas.Font := Font;
    Caption := 'Select Recipients';
    BorderStyle := bsDialog;
    color := clmedgray;
    PopupMode := pmAuto;
    Position := poScreenCenter;
    Width := 550;
    Height := 324;
  end;

  lblHeading := TLabel.Create(Form);
  with lblHeading do
  begin
   Parent := Form;
   name := 'lblHeading';
   Caption := 'Select the Recipients of this message :';
   //Color := clMedGray;
   Font.Name := 'Tahoma';
   Font.Style := [fsBold , fsUnderline];
   Font.Size := 20;
   Visible := true;
   Enabled := true;
   Height := 39;
   Left := 8;
   Top := 0;
   if Width > FOrm.Width - 25 then
   Height := Height * Ceil(width / Form.Width - 25);
   Width := Form.Width - 25;
   WordWrap := true;
  end;

  rgb := TRadioGroup.Create(Form);
  with rgb do
  begin
   Parent := Form;
   Name := 'rgbSelect';
   Caption := 'Selection Filter';
   Items.Add('Name');
   Items.Add('Email-Adress');
   ItemIndex := 0;
   sField := 'UserName';
   Width := 97;
   Top := lblHeading.Top + lblHEading.Height + 5;
   HEight := 42;
   LEft := 13;

  end;

    ScrollBox := TScrollBox.Create(Form);
  with ScrollBox do
  begin
   Parent := Form;
   Name := 'ScrollBox';
   Left := (rgb.Left + rgb.Width + 5);
   Width := FOrm.Width - (rgb.Left + rgb.Width + 20) ;
   Top := lblHeading.Top + lblHEading.Height + 5;
   Height := (FOrm.Height) - (lblHeading.Top + lblHEading.Height + 80);
  end;

  btn[0] := TButton.Create(Form);
  with btn[0] do
  begin
   Parent := Form;
   Name := 'btnCancel';
   Caption := 'Cancel';
   Top := ScrollBox.Top + ScrollBox.Height + 10;
   Width := 75;
   Height := 25;
   LEft := 194;
   ModalResult := mrcancel;
  end;

  btn[1] := TButton.Create(Form);
  with btn[1] do
  begin
   Parent := Form;
   Name := 'btnContinue';
   Caption := 'Continue';
   Top := ScrollBox.Top + ScrollBox.Height + 10;
   Width := 75;
   Height := 25;
   LEft := 304;
   ModalResult := mrok;
  end;

  btn[2] := TButton.Create(Form);
  with btn[2] do
  begin
   Parent := Form;
   Name := 'btnUpdate';
   Caption := 'Update';
   Top := rgb.Top + rgb.Height;
   Width := rgb.Width;
   Height := 25;
   LEft := rgb.left;
   ModalResult := mrUpdate;
  end;



   uJHB_DB.JHBdataModule.DB_usrtbl.First;
    while NOT(uJHB_DB.JHBdataModule.DB_usrtbl.Eof) do
     begin

      Setlength(cb , length(cb)+1);
      cb[length(cb)-1] := TCheckBox.Create(Form);

      with cb[length(cb)-1] do
      begin
        Parent := ScrollBox;
        Name := 'cb' + inttostr(length(cb)-1);
        Caption := uJHB_DB.JHBdataModule.DB_usrtbl['UserName'];
        Font.Size := 10;
        Width := (Length(Caption)*8)+16;
        if length(cb) > 1 then
        Top := cb[length(cb)-2].HEight + cb[length(cb)-2].Top;
      end;

      uJHB_DB.JHBdataModule.DB_usrtbl.Next;
     end;



  bFormOpen := true;
  while bFormOpen = true do
  begin

   iFormModal := Form.ShowMOdal;

   if iFormModal = mrCancel then
   begin
     Result := false;
     bFormOpen := false;
   end;

   if iFormModal = mrUpdate then
   begin
    case rgb.ItemIndex of
    0 : sField := 'UserName';
    1 : sField := 'UserEmail';
    end;
    icount := -1;
    uJHB_DB.JHBdataModule.DB_usrtbl.First;
    while NOT(uJHB_DB.JHBdataModule.DB_usrtbl.Eof) do
     begin
        INC(icount);
        cb[icount].Caption := uJHB_DB.JHBdataModule.DB_usrtbl[sField];
        cb[icount].Width := (Length(cb[icount].Caption)*8)+16;
        uJHB_DB.JHBdataModule.DB_usrtbl.Next;
     end;
   end;



    if iFormModal = mrok then
   begin

     Result := true;
     bFormOpen := false;
     Setlength(arrUsers,0);
     for icount := 0 to length(cb)-1 do
       begin
        if cb[icount].Checked = true then
         begin
         if (uJHB_DB.JHBdataModule.DB_usrtbl.Locate(sField , cb[icount].Caption , []) = true) then
           begin
           Setlength(arrUsers,length(arrUsers)+1);
           ArrUsers[length(arrUsers)-1] := uJHB_DB.JHBdataModule.DB_usrtbl['UserUniqueCode'] + chr(0) + uJHB_DB.JHBdataModule.DB_usrtbl['UserEmail'] + chr(0)
            + uJHB_DB.JHBdataModule.DB_usrtbl['UserName'];
           end
           else
           begin
             showmessage('This user does not exist in the database : ' + cb[icount].Caption)
           end;


         end;

       end;

   end;



  end;



 finally
  FreeAndNil(Form);
 end;

end;





Function JHBInputQuery(const sCaption , sHeading , sDiscription : string ; var sVar : string) : boolean; overload;
var
Form : TForm;
lblHeading : Tlabel;
lblDescription : TLabel;
RedtVar : TRichEdit;
btn : Array[0..2] of TButton;
TF : TextFile;
sPath , sLine : string;
iFormModal : integer;
bFormOpen : boolean;
begin
 Result := false;

 try
 Form := TForm.Create(application);
 with Form do
  begin
    Canvas.Font := Font;
    Caption := sCaption;
    BorderStyle := bsDialog;
    color := clmedgray;
    PopupMode := pmAuto;
    Position := poScreenCenter;
    Width := 638;
    Height := 324;
  end;

 lblHeading := TLabel.Create(Form);
 with lblHeading do
 begin
  Parent := Form;
  name := 'lblHeading';
  Caption := sHeading;
  //Color := clMedGray;
  Font.Name := 'Tahoma';
  Font.Style := [fsBold , fsUnderline];
  Font.Size := 24;
  Visible := true;
  Enabled := true;
  Height := 39;
  Left := 8;
  Top := -5;
  if Width > FOrm.Width - 25 then
  Height := Height * Ceil(width / Form.Width - 25);
  Width := Form.Width - 25;
  WordWrap := true;
 end;

 lblDescription := TLabel.Create(Form);
 with lblDescription do
 begin
  Parent := Form;
  name := 'lblDescription';
  Caption := sDiscription;
  Font.name :=   'Tahoma' ;
  Font.Size :=  12 ;
  Visible :=   true ;
  Enabled :=  true ;
  Height := 23;
  left :=   8;
  Top :=  lblHeading.Top + lblHeading.Height ;
  if Width > FOrm.Width - 25 then
  Height := Height * Ceil(width / Form.Width - 25);
  Width := Form.Width - 25;
  WordWrap := true;
 end;

 RedtVar := TRichedit.Create(Form);
 with RedtVar do
 begin
   Parent := Form;
   name := 'RedtVar';
   Lines.clear;
   Lines[0] := (sVar);
   Top := lblDescription.Top + lblDescription.Height + 21;
   left := 8;
   Height := 160;
   Width := Form.Width - 25;
 end;


    btn[0] := tButton.Create(Form);
 with btn[0] do
 begin
   parent := Form;
   Name := 'BtnReadFromTF';
   Caption := 'Get From TextFile';
   Width :=  109;
   Height := 20;
   Top :=  lblDescription.Top + lblDescription.Height;
   Left := 8;
   btn[0].ModalResult := 99;

 end;

 btn[1] := tButton.Create(Form);
 with btn[1] do
 begin
   parent := Form;
   Name := 'BtnContinue';
   ModalResult := mrOk;
   Caption := 'Continue';
   HEight :=  25;
   Width :=   75;
   Top :=  RedtVar.Height + RedtVar.Top + 9;
   Left :=  (Form.Width DIV 2);
 end;

 btn[2] := tButton.Create(Form);
 with btn[2] do
 begin
   parent := Form;
   Name := 'BtnCancel';
   ModalResult := mrCancel;
   Caption := 'Cancel';
   HEight :=  25;
   Width := 75;
   Top :=   RedtVar.Height + RedtVar.Top + 9;
   Left :=  (Form.Width DIV 2)- (width) ;
 end;

 Form.Height := Btn[2].Height + btn[2].Top + 35;
 bFormOpen := true;
 while bFormOpen = true do
 begin
 iFormModal := Form.ShowModal;

 if iFormModal = mrCancel then
  begin
    Result := false;
    bFormOpen := false;

  end;

    if iFormModal = mrok then
 begin
   Result := true;
   sVar := RedtVar.Text;
   bFormOpen := false;
 end;

  if iFormModal = 99 then
 begin

 while sPath = '' do
 begin
 sPath := JHBWindowsOpenDialog('Select Text File','Text files only|*.txt;*.rtf;');
 if sPath = '' then
 if messageDLG('You did not select a text file , are you sure you want to continue' , mtWarning , [mbYes , mbNo] , 0) = mrYes then
 begin
 JHBInputQuery(sCaption , sHeading ,sDiscription , sVar);
 Exit;
 end;
 end;
 RedtVar.Clear;
 AssignFile(TF , sPath);
 Reset(TF);
   while not EOF(TF) do
   begin
     Readln(TF , sLine);
     RedtVar.Lines.add(sLine);
   end;
  CloseFile(TF);

 end;
 end;

 finally
  FreeAndNil(Form);
 end;


end;


procedure WriteToDebugtf(Sinput : string);
var
TF : TextFile;
begin
AssignFile(tf,'C:\Users\jhbri\OneDrive\Desktop\tf.txt');
if Not FileExists('C:\Users\jhbri\OneDrive\Desktop\tf.txt') then
Rewrite(tf);

Append(tf);
Writeln(tf,SInput);
closeFile(tf);
end;


function GetThisUnitName: string;
begin
  try
    assert(false, '#');
  except
    on Exception: EAssertionFailed do
      Result := Copy(Exception.Message, 4, length(Exception.Message) - 14);
    // Dirty solution
  end;
end;

Initialization

sThisUnitDir := GetThisUnitName;


{
  function SendEmailMAPI(const arrTO ,arrCC , arrBCC , arrAttachments: array of string; const Body , Subject  : string) : integer;
  const
  SenderName = 'JHBEncryptAndDecrypt';
  SenderEmail = 'jhbencryptanddecrypt@gmail.com';
  var
  SM : TFNMapiSendMail;
  MAPIModule: HModule;
  Msg : MapiMessage;
  lpSender: MapiRecipDesc;
  Recipients : array of MapiRecipDesc;
  Attachments : array of MapiFileDesc;
  icount1 , icount2 , icount3 : Integer;
  sError : string;
  begin
  try
  FillChar(Msg, SizeOf(Msg), 0);

  Setlength(REcipients , length(arrTO) + length(ArrCC) + length(ArrBCC));
  Setlength(Attachments , length(arrAttachments));
  {to
  for icount1 := 0 to length(ArrTo)- 1 do
  begin
  FillChar(Recipients[icount1] , Sizeof(Recipients[icount1]) , 0);

  with Recipients[icount1] do
  begin
  ulReserved := 0;
  ulRecipClass := MAPI_TO;
  lpszName := pAnsichar(AnsiString(arrTo[icount1]));
  lpszAddress := '';
  end;

  end;
  {cc
  for icount2 := 0 to length(ArrCC)- 1 do
  begin
  FillChar(Recipients[icount1 + icount2] , Sizeof(Recipients[icount1 + icount2]) , 0);

  with Recipients[icount1 + icount2] do
  begin
  ulReserved := 0;
  ulRecipClass := MAPI_CC;
  lpszName := pAnsichar(AnsiString(arrCC[icount2]));
  lpszAddress := '';
  end;
  end;
  {bcc
  for icount3 := 0 to length(arrBCC) -1 do
  begin
  FillChar(Recipients[icount1 + icount2 + icount3] , Sizeof(Recipients[icount1 + icount2 + icount3]) , 0);

  with  Recipients[icount1 + icount2 + icount3] do
  begin
  ulReserved := 0;
  ulRecipClass := MAPI_CC;
  lpszName := pAnsichar(AnsiString(arrBCC[icount3]));
  lpszAddress := '';
  end;

  end;

  for icount1  := 0 to length(arrAttachments)-1 do
  begin
  FillChar(Attachments[icount1], SizeOf(attachments[icount1]), 0);

  with Attachments[icount1] do
  begin
  ulReserved := 0;
  flFlags := 0;
  nPosition := Cardinal($FFFFFFFF);  {Not sure =\
  lpszPathname := pAnsiChar(AnsiString(ArrAttachments[icount1]));
  lpszFilename := '';
  lpFileType := nil;
  end;
  { fill the message

  with msg do
  begin
  ulReserved := 0;

  if subject <> '' then
  lpszSubject := pAnsichar(AnsiString(subject));

  if body <> '' then
  lpszNoteText := pAnsichar(AnsiString(body));

  if SenderEmail <> '' then
  begin
  lpsender.ulRecipClass := MAPI_ORIG;

  if SenderName = '' then
  lpSender.lpszName := pAnsiChar(AnsiString(SenderEmail))
  else
  lpSender.lpszName := pAnsiChar(AnsiString(SenderName));

  lpSender.lpszAddress := pAnsichar(AnsiString(SenderEmail));
  lpSender.ulEIDSize := 0;
  lpSender.lpEntryID := nil;
  lpOriginator := @lpSender;
  end
  else
  Msg.lpOriginator := nil;

  lpszMessageType := nil;
  lpszDateReceived := nil;
  lpszConversationID := nil;
  flFlags := 0;
  nRecipCount := length(arrTo) + length(arrCC) + length(arrBCC);
  lpRecips := @Recipients[0];
  nFileCount := length(arrAttachments);
  lpFiles := @Attachments[0];
  end;

  MAPIModule := LoadLibrary(PwideChar(MAPIDLL));
  if MAPIModule = 0 then
  Result := -1
  else
  try
  @SM := GetProcAddress(MAPIModule, 'MAPISendMail');
  if @SM <> nil then
  begin
  Result := SM(0, application.Handle, Msg, { MAPI_DIALOG or  MAPI_LOGON_UI, 0);
  end
  else
  Result := 1;
  finally
  FreeLibrary(MAPIModule);
  end;
  //ERROR CHECK  ( COPPIED )!!!!  //PLZ REFRENCE http://delphiprogrammingdiary.blogspot.com/2014/12/how-to-send-email-in-delphi.html
  if Result <> SUCCESS_SUCCESS then
  begin
  case Result of
  MAPI_E_ACCESS_DENIED:
  sError := 'Access denied.';
  MAPI_E_AMBIGUOUS_RECIPIENT:
  sError := 'Ambiguous recipient.';
  MAPI_E_ATTACHMENT_NOT_FOUND:
  sError := 'Attachment not found.';
  MAPI_E_ATTACHMENT_OPEN_FAILURE:
  sError := 'Attachment open failure.';
  MAPI_E_ATTACHMENT_WRITE_FAILURE:
  sError := 'Attachment write failure.';
  MAPI_E_BAD_RECIPTYPE:
  sError := 'Bad recipient type.';
  MAPI_E_DISK_FULL:
  sError := 'Disk full.';
  MAPI_E_FAILURE:
  sError := 'Failure';
  MAPI_E_INSUFFICIENT_MEMORY:
  sError := 'Insufficient Memory.';
  MAPI_E_INVALID_EDITFIELDS:
  sError := 'Invalid Editfields.';
  MAPI_E_INVALID_MESSAGE:
  sError := 'Invalid message.';
  MAPI_E_INVALID_RECIPS:
  sError := 'Invalid recipients.';
  MAPI_E_INVALID_SESSION:
  sError := 'Invalid session.';
  MAPI_E_LOGIN_FAILURE:
  sError := 'Login failure.';
  MAPI_E_MESSAGE_IN_USE:
  sError := 'Message in use.';
  MAPI_E_NETWORK_FAILURE:
  sError := 'Network failure.';
  MAPI_E_NO_MESSAGES:
  sError := 'No messages.';
  MAPI_E_NOT_SUPPORTED:
  sError := 'Not supported.';
  MAPI_E_TEXT_TOO_LARGE:
  sError := 'Text too large.';
  MAPI_E_TOO_MANY_FILES:
  sError := 'Too many files.';
  MAPI_E_TOO_MANY_RECIPIENTS:
  sError := 'Too many recipients.';
  MAPI_E_TOO_MANY_SESSIONS:
  sError := 'Too many sessions.';
  MAPI_E_TYPE_NOT_SUPPORTED:
  sError := 'Type not supported.';
  MAPI_E_UNKNOWN_RECIPIENT:
  sError := 'Unknown Recipient';
  MAPI_E_USER_ABORT:
  sError := 'User Aborted';
  end;
  if sError <> '' then
  begin
  MessageDlg('Could not send email.  ' + sError, mtInformation, [mbOk], 0);
  Exit;
  end;
  end;
  end;
  finally
  end;
  end; }

end.
